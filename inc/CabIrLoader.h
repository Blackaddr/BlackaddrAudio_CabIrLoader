/*
 * Company: Blackaddr Audio
 * Effect Name: Cab IR Loader
 * Description: A guitar cab IR loader with optional lowpass and highpass shelving filters to tweak the sound.
 *
 * This file was auto-generated by Aviate Audio Effect Creator for the Multiverse.
 */
#pragma once

#include <Audio.h>
#include <arm_math.h>
#include "Aviate/AudioEffectWrapper.h"

//!s - START_USER_INCLUDES - put your #includes below this line before the matching END
//!e - END_USER_INCLUDES

namespace BlackaddrAudio_CabIrLoader {

//!s - START_USER_EFFECT_TYPES - put your effect types below this line before the matching END
// constexpr size_t MAX_IR_PARTITIONS = 8;
// constexpr size_t MAX_IR_SAMPLES = 128 * MAX_IR_PARTITIONS;
typedef struct {
    float alpha;
    float yPrev;
    float xPrev;
} LowPassFilter_t;

//!e - END_USER_EFFECT_TYPES

class CabIrLoader : public AudioStream, public Aviate::AudioEffectWrapper {
public:
    static constexpr unsigned NUM_INPUTS  = 2;
    static constexpr unsigned NUM_OUTPUTS = 2;

    // List of effect control names
    enum {
        Bypass_e = 0,
        Volume_e = 1,
        CabSelect_e = 2,
        LoPass1KHz_e = 3,
        HiPass1Hz_e = 4,
        FilterEnable_e = 5,
        NUM_CONTROLS
    };

    //!s - START_USER_CLASS_TYPES - put your custom class types below this line before the matching END
    //!e - END_USER_CLASS_TYPES

    CabIrLoader();

    //!s - START_USER_CONSTRUCTORS - put your custom constructors below this line before the matching END
    //!e - END_USER_CONSTRUCTORS

    virtual ~CabIrLoader();

    // Standard EFX interface functions - do not change these declaration
    virtual void update(); // main audio processing loop function
    void mapMidiControl(int parameter, int midiCC, int midiChannel = 0) override;
    void processMidi(int channel, int midiCC, int value) override;
    void setParam(int paramIndex, float paramValue) override;
    float getUserParamValue(int paramIndex, float normalizedParamValue);
    const char* getName() override;
    const uint8_t* getRblk() override;

    // control value set functions, must take floats between 0.0f and 1.0f - do not change these declarations
    void volume(float value) override;
    void cabselect(float value);
    void lopass1khz(float value);
    void hipass1hz(float value);
    void filterenable(float value);

    //!s - START_USER_PUBLIC_MEMBERS - put your public members below this line before the matching END
    //!e - END_USER_PUBLIC_MEMBERS

private:
    audio_block_t *m_inputQueueArray[2]; // required by AudioStream base class, array size is num inputs
    int m_midiConfig[NUM_CONTROLS][2]; // stores the midi parameter mapping

    // m_bypass and m_volume are already provided by the base class AudioEffectWrapper
    float m_cabselect = 0.0f;
    float m_lopass1khz = 0.0f;
    float m_hipass1hz = 0.0f;
    float m_filterenable = 0.0f;

    audio_block_t* m_basicInputCheck(audio_block_t* inputAudioBlock, unsigned outputChannel);

    //!s - START_USER_PRIVATE_MEMBERS - put your private members below this line before the matching END
    bool m_impulseLoaded = false;
    int buffidx;


    static constexpr size_t MAX_IR_PARTITIONS = 8;
    float32_t fmask[MAX_IR_PARTITIONS][512]; // Effect is 10% faster with fmask on stack instead of heap
    //float* fmask = nullptr;

    float32_t fftin[512];

    float* last_sample_buffer_L = nullptr;
    float* last_sample_buffer_R = nullptr;

    float32_t accum[512];
    float32_t ac2[512];
    float32_t* ptr_fmask;
    float32_t* ptr_fftout;

    bool   m_configComplete = false;
    size_t m_partitionSize;
    size_t m_numSamplesIr;
    size_t n_numPartitionsIr;
    size_t m_fftLength;
    float* fftout = nullptr;
    float* maskgen = nullptr;

    unsigned m_cabSelectIdx = 0;

    bool m_config(unsigned selectedIr);
    void m_impulse(const float32_t *coefs,float32_t *maskgen,int size);

    bool m_filterEnable = true;
    LowPassFilter_t m_lpf_L, m_lpf_R, m_hpf_L, m_hpf_R;
    //!e - END_USER_PRIVATE_MEMBERS

};

}
